/* Generated by Nim Compiler v0.11.3 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -Os  -I/data4/NimCompiler/Nim/lib -o nimcache/stdlib_parsecsv.o nimcache/stdlib_parsecsv.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct Csvparser257007 Csvparser257007;
typedef struct Baselexer255024 Baselexer255024;
typedef struct TNimObject TNimObject;
typedef struct Streamobj186027 Streamobj186027;
typedef struct TY120008 TY120008;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct Cell44747 Cell44747;
typedef struct Cellseq44763 Cellseq44763;
typedef struct Gcheap46616 Gcheap46616;
typedef struct Cellset44759 Cellset44759;
typedef struct Pagedesc44755 Pagedesc44755;
typedef struct Memregion26610 Memregion26610;
typedef struct Smallchunk25843 Smallchunk25843;
typedef struct Llchunk26604 Llchunk26604;
typedef struct Bigchunk25845 Bigchunk25845;
typedef struct Intset25817 Intset25817;
typedef struct Trunk25813 Trunk25813;
typedef struct Avlnode26608 Avlnode26608;
typedef struct Gcstat46614 Gcstat46614;
typedef struct Csverror257009 Csverror257009;
typedef struct Ioerror3431 Ioerror3431;
typedef struct Systemerror3429 Systemerror3429;
typedef struct Exception Exception;
typedef struct Basechunk25841 Basechunk25841;
typedef struct Freecell25833 Freecell25833;
typedef N_NIMCALL_PTR(void, TY3289) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3294) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3289 marker;
TY3294 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  TNimObject  {
TNimType* m_type;
};
struct  Baselexer255024  {
  TNimObject Sup;
NI bufpos;
NCSTRING buf;
NI buflen;
Streamobj186027* input;
NI linenumber;
NI sentinel;
NI linestart;
NIM_BOOL fileopened;
};
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  Csvparser257007  {
  Baselexer255024 Sup;
TY120008* row;
NimStringDesc* filename;
NIM_CHAR sep;
NIM_CHAR quote;
NIM_CHAR esc;
NIM_BOOL skipwhite;
NI currrow;
};
struct  Cell44747  {
NI refcount;
TNimType* typ;
};
struct  Cellseq44763  {
NI len;
NI cap;
Cell44747** d;
};
struct  Cellset44759  {
NI counter;
NI max;
Pagedesc44755* head;
Pagedesc44755** data;
};
typedef Smallchunk25843* TY26622[512];
typedef Trunk25813* Trunkbuckets25815[256];
struct  Intset25817  {
Trunkbuckets25815 data;
};
struct  Memregion26610  {
NI minlargeobj;
NI maxlargeobj;
TY26622 freesmallchunks;
Llchunk26604* llmem;
NI currmem;
NI maxmem;
NI freemem;
NI lastsize;
Bigchunk25845* freechunkslist;
Intset25817 chunkstarts;
Avlnode26608* root;
Avlnode26608* deleted;
Avlnode26608* last;
Avlnode26608* freeavlnodes;
};
struct  Gcstat46614  {
NI stackscans;
NI cyclecollections;
NI maxthreshold;
NI maxstacksize;
NI maxstackcells;
NI cycletablesize;
NI64 maxpause;
};
struct  Gcheap46616  {
void* stackbottom;
NI cyclethreshold;
Cellseq44763 zct;
Cellseq44763 decstack;
Cellset44759 cycleroots;
Cellseq44763 tempstack;
NI recgclock;
Memregion26610 region;
Gcstat46614 stat;
};
struct  Exception  {
  TNimObject Sup;
Exception* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct  Systemerror3429  {
  Exception Sup;
};
struct  Ioerror3431  {
  Systemerror3429 Sup;
};
struct  Csverror257009  {
  Ioerror3431 Sup;
};
typedef N_NIMCALL_PTR(void, TY186028) (Streamobj186027* s);
typedef N_NIMCALL_PTR(NIM_BOOL, TY186032) (Streamobj186027* s);
typedef N_NIMCALL_PTR(void, TY186036) (Streamobj186027* s, NI pos);
typedef N_NIMCALL_PTR(NI, TY186041) (Streamobj186027* s);
typedef N_NIMCALL_PTR(NI, TY186045) (Streamobj186027* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(NI, TY186051) (Streamobj186027* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY186057) (Streamobj186027* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY186063) (Streamobj186027* s);
struct  Streamobj186027  {
  TNimObject Sup;
TY186028 closeimpl;
TY186032 atendimpl;
TY186036 setpositionimpl;
TY186041 getpositionimpl;
TY186045 readdataimpl;
TY186051 peekdataimpl;
TY186057 writedataimpl;
TY186063 flushimpl;
};
typedef NI TY25820[8];
struct  Pagedesc44755  {
Pagedesc44755* next;
NI key;
TY25820 bits;
};
struct  Basechunk25841  {
NI prevsize;
NI size;
NIM_BOOL used;
};
struct  Smallchunk25843  {
  Basechunk25841 Sup;
Smallchunk25843* next;
Smallchunk25843* prev;
Freecell25833* freelist;
NI free;
NI acc;
NF data;
};
struct  Llchunk26604  {
NI size;
NI acc;
Llchunk26604* next;
};
struct  Bigchunk25845  {
  Basechunk25841 Sup;
Bigchunk25845* next;
Bigchunk25845* prev;
NI align;
NF data;
};
struct  Trunk25813  {
Trunk25813* next;
NI key;
TY25820 bits;
};
typedef Avlnode26608* TY26614[2];
struct  Avlnode26608  {
TY26614 link;
NI key;
NI upperbound;
NI level;
};
struct  Freecell25833  {
Freecell25833* next;
NI zerofield;
};
struct TY120008 {
  TGenericSeq Sup;
  NimStringDesc* data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, open_255040)(Baselexer255024* L, Streamobj186027* input, NI buflen);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* seq, NI elemsize, NI newlen);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(Cell44747*, usrtocell_48246)(void* usr);
static N_INLINE(void, rtladdzct_49804)(Cell44747* c);
N_NOINLINE(void, addzct_48217)(Cellseq44763* s, Cell44747* c);
N_NIMCALL(void, parsefield_257092)(Csvparser257007* my, NimStringDesc** a);
N_NIMCALL(NimStringDesc*, setLengthStr)(NimStringDesc* s, NI newlen);
N_NIMCALL(void, error_257049)(Csvparser257007* my, NI pos, NimStringDesc* msg);
N_NIMCALL(void, raiseeinvalidcsv_257026)(NimStringDesc* filename, NI line, NI col, NimStringDesc* msg) __attribute__((noreturn));
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP384)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void, raiseException)(Exception* e, NCSTRING ename);
N_NIMCALL(NI, getcolnumber_255064)(Baselexer255024* L, NI pos);
static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(NI, handlecr_255071)(Baselexer255024* L, NI pos);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(NI, handlelf_255079)(Baselexer255024* L, NI pos);
STRING_LITERAL(TMP383, "", 0);
STRING_LITERAL(TMP385, "(", 1);
STRING_LITERAL(TMP386, ", ", 2);
STRING_LITERAL(TMP387, ") Error: ", 9);
STRING_LITERAL(TMP388, " expected", 9);
STRING_LITERAL(TMP389, "\012", 1);
STRING_LITERAL(TMP390, " columns expected, but found ", 29);
STRING_LITERAL(TMP391, " columns", 8);
extern TNimType NTI255024; /* BaseLexer */
TNimType NTI257007; /* CsvParser */
extern TNimType NTI120008; /* seq[string] */
extern TNimType NTI149; /* string */
extern TNimType NTI147; /* char */
extern TNimType NTI138; /* bool */
extern TNimType NTI108; /* int */
extern Gcheap46616 gch_46648;
extern TNimType NTI3431; /* IOError */
TNimType NTI257009; /* CsvError */
TNimType NTI257032; /* ref CsvError */

N_NIMCALL(void, open_257060)(Csvparser257007* my, Streamobj186027* input, NimStringDesc* filename, NIM_CHAR separator, NIM_CHAR quote, NIM_CHAR escape, NIM_BOOL skipinitialspace) {
	Baselexer255024* LOC1;
	LOC1 = 0;
	LOC1 = &my->Sup;
	open_255040(LOC1, input, ((NI) 8192));
	unsureAsgnRef((void**) (&(*my).filename), copyString(filename));
	(*my).sep = separator;
	(*my).quote = quote;
	(*my).esc = escape;
	(*my).skipwhite = skipinitialspace;
	unsureAsgnRef((void**) (&(*my).row), (TY120008*) newSeq((&NTI120008), 0));
	(*my).currrow = ((NI) 0);
}

static N_INLINE(Cell44747*, usrtocell_48246)(void* usr) {
	Cell44747* result;
	result = 0;
	result = ((Cell44747*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(Cell44747))))));
	return result;
}

static N_INLINE(void, rtladdzct_49804)(Cell44747* c) {
	addzct_48217((&gch_46648.zct), c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	Cell44747* c;
	c = usrtocell_48246(p);
	{
		(*c).refcount -= ((NI) 8);
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		rtladdzct_49804(c);
	}
	LA3: ;
}
N_NIMCALL(void, TMP384)(void* p, NI op) {
	Csverror257009* a;
	a = (Csverror257009*)p;
	nimGCvisit((void*)(*a).Sup.Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.trace, op);
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) ((&(*dest).data[((*dest).Sup.len)- 0]))), ((NCSTRING) ((*src).data)), (NI)((*src).Sup.len + ((NI) 1)));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		Cell44747* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_48246(src);
		(*c).refcount += ((NI) 8);
	}
	LA3: ;
	{
		Cell44747* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_48246((*dest));
		{
			(*c).refcount -= ((NI) 8);
			if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA11;
			rtladdzct_49804(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(void, raiseeinvalidcsv_257026)(NimStringDesc* filename, NI line, NI col, NimStringDesc* msg) {
	Csverror257009* e;
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	e = 0;
	e = (Csverror257009*) newObj((&NTI257032), sizeof(Csverror257009));
	(*e).Sup.Sup.Sup.Sup.m_type = (&NTI257009);
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = nimIntToStr(line);
	LOC3 = 0;
	LOC3 = nimIntToStr(col);
	LOC1 = rawNewString(filename->Sup.len + LOC2->Sup.len + LOC3->Sup.len + msg->Sup.len + 12);
appendString(LOC1, filename);
appendString(LOC1, ((NimStringDesc*) &TMP385));
appendString(LOC1, LOC2);
appendString(LOC1, ((NimStringDesc*) &TMP386));
appendString(LOC1, LOC3);
appendString(LOC1, ((NimStringDesc*) &TMP387));
appendString(LOC1, msg);
	asgnRefNoCycle((void**) (&(*e).Sup.Sup.Sup.message), LOC1);
	raiseException((Exception*)e, "CsvError");
}

N_NIMCALL(void, error_257049)(Csvparser257007* my, NI pos, NimStringDesc* msg) {
	NI LOC1;
	LOC1 = 0;
	LOC1 = getcolnumber_255064((&(*my).Sup), pos);
	raiseeinvalidcsv_257026((*my).filename, (*my).Sup.linenumber, LOC1, msg);
}

static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c) {
	(*dest).data[((*dest).Sup.len)- 0] = c;
	(*dest).data[((NI)((*dest).Sup.len + ((NI) 1)))- 0] = 0;
	(*dest).Sup.len += ((NI) 1);
}

N_NIMCALL(void, parsefield_257092)(Csvparser257007* my, NimStringDesc** a) {
	NI pos;
	NCSTRING buf;
	pos = (*my).Sup.bufpos;
	buf = (*my).Sup.buf;
	{
		if (!(*my).skipwhite) goto LA3;
		{
			while (1) {
				if (!(((NU8)(buf[pos])) == ((NU8)(32)) || ((NU8)(buf[pos])) == ((NU8)(9)))) goto LA6;
				pos += ((NI) 1);
			} LA6: ;
		}
	}
	LA3: ;
	(*a) = setLengthStr((*a), ((NI) 0));
	{
		NIM_BOOL LOC9;
		LOC9 = 0;
		LOC9 = ((NU8)(buf[pos]) == (NU8)((*my).quote));
		if (!(LOC9)) goto LA10;
		LOC9 = !(((NU8)((*my).quote) == (NU8)(0)));
		LA10: ;
		if (!LOC9) goto LA11;
		pos += ((NI) 1);
		{
			while (1) {
				NIM_CHAR c;
				c = buf[pos];
				{
					NimStringDesc* LOC19;
					if (!((NU8)(c) == (NU8)(0))) goto LA17;
					(*my).Sup.bufpos = pos;
					LOC19 = 0;
					LOC19 = rawNewString(10);
appendChar(LOC19, (*my).quote);
appendString(LOC19, ((NimStringDesc*) &TMP388));
					error_257049((&(*my)), pos, LOC19);
					goto LA13;
				}
				goto LA15;
				LA17: ;
				{
					if (!((NU8)(c) == (NU8)((*my).quote))) goto LA21;
					{
						NIM_BOOL LOC25;
						LOC25 = 0;
						LOC25 = ((NU8)((*my).esc) == (NU8)(0));
						if (!(LOC25)) goto LA26;
						LOC25 = ((NU8)(buf[(NI)(pos + ((NI) 1))]) == (NU8)((*my).quote));
						LA26: ;
						if (!LOC25) goto LA27;
						(*a) = addChar((*a), (*my).quote);
						pos += ((NI) 2);
					}
					goto LA23;
					LA27: ;
					{
						pos += ((NI) 1);
						goto LA13;
					}
					LA23: ;
				}
				goto LA15;
				LA21: ;
				{
					if (!((NU8)(c) == (NU8)((*my).esc))) goto LA31;
					(*a) = addChar((*a), buf[(NI)(pos + ((NI) 1))]);
					pos += ((NI) 2);
				}
				goto LA15;
				LA31: ;
				{
					switch (((NU8)(c))) {
					case 13:
					{
						Baselexer255024* LOC35;
						LOC35 = 0;
						LOC35 = &my->Sup;
						pos = handlecr_255071(LOC35, pos);
						buf = (*my).Sup.buf;
						(*a) = resizeString((*a), 1);
appendString((*a), ((NimStringDesc*) &TMP389));
					}
					break;
					case 10:
					{
						Baselexer255024* LOC37;
						LOC37 = 0;
						LOC37 = &my->Sup;
						pos = handlelf_255079(LOC37, pos);
						buf = (*my).Sup.buf;
						(*a) = resizeString((*a), 1);
appendString((*a), ((NimStringDesc*) &TMP389));
					}
					break;
					default:
					{
						(*a) = addChar((*a), c);
						pos += ((NI) 1);
					}
					break;
					}
				}
				LA15: ;
			}
		} LA13: ;
	}
	goto LA7;
	LA11: ;
	{
		{
			while (1) {
				NIM_CHAR c;
				c = buf[pos];
				{
					if (!((NU8)(c) == (NU8)((*my).sep))) goto LA44;
					goto LA40;
				}
				LA44: ;
				{
					if (!(((NU8)(c)) == ((NU8)(13)) || ((NU8)(c)) == ((NU8)(10)) || ((NU8)(c)) == ((NU8)(0)))) goto LA48;
					goto LA40;
				}
				LA48: ;
				(*a) = addChar((*a), c);
				pos += ((NI) 1);
			}
		} LA40: ;
	}
	LA7: ;
	(*my).Sup.bufpos = pos;
}

N_NIMCALL(NIM_BOOL, readrow_257225)(Csvparser257007* my, NI columns) {
	NIM_BOOL result;
	NI col;
	NI oldpos;
	result = 0;
	col = ((NI) 0);
	oldpos = (*my).Sup.bufpos;
	{
		while (1) {
			NI oldlen;
			if (!!(((NU8)((*my).Sup.buf[(*my).Sup.bufpos]) == (NU8)(0)))) goto LA2;
			oldlen = ((*my).row ? (*my).row->Sup.len : 0);
			{
				NimStringDesc* LOC7;
				if (!(oldlen < (NI)(col + ((NI) 1)))) goto LA5;
				(*my).row = (TY120008*) setLengthSeq(&((*my).row)->Sup, sizeof(NimStringDesc*), ((NI) ((NI)(col + ((NI) 1)))));
				LOC7 = 0;
				LOC7 = (*my).row->data[col]; (*my).row->data[col] = copyStringRC1(((NimStringDesc*) &TMP383));
				if (LOC7) nimGCunrefNoCycle(LOC7);
			}
			LA5: ;
			parsefield_257092(my, (&(*my).row->data[col]));
			col += ((NI) 1);
			{
				if (!((NU8)((*my).Sup.buf[(*my).Sup.bufpos]) == (NU8)((*my).sep))) goto LA10;
				(*my).Sup.bufpos += ((NI) 1);
			}
			goto LA8;
			LA10: ;
			{
				switch (((NU8)((*my).Sup.buf[(*my).Sup.bufpos]))) {
				case 13:
				case 10:
				{
					{
						while (1) {
							switch (((NU8)((*my).Sup.buf[(*my).Sup.bufpos]))) {
							case 13:
							{
								Baselexer255024* LOC17;
								LOC17 = 0;
								LOC17 = &my->Sup;
								(*my).Sup.bufpos = handlecr_255071(LOC17, (*my).Sup.bufpos);
							}
							break;
							case 10:
							{
								Baselexer255024* LOC19;
								LOC19 = 0;
								LOC19 = &my->Sup;
								(*my).Sup.bufpos = handlelf_255079(LOC19, (*my).Sup.bufpos);
							}
							break;
							default:
							{
								goto LA14;
							}
							break;
							}
						}
					} LA14: ;
				}
				break;
				case 0:
				{
				}
				break;
				default:
				{
					NimStringDesc* LOC23;
					LOC23 = 0;
					LOC23 = rawNewString(10);
appendChar(LOC23, (*my).sep);
appendString(LOC23, ((NimStringDesc*) &TMP388));
					error_257049((&(*my)), (*my).Sup.bufpos, LOC23);
				}
				break;
				}
				goto LA1;
			}
			LA8: ;
		} LA2: ;
	} LA1: ;
	(*my).row = (TY120008*) setLengthSeq(&((*my).row)->Sup, sizeof(NimStringDesc*), ((NI) (col)));
	result = (((NI) 0) < col);
	{
		NIM_BOOL LOC26;
		NIM_BOOL LOC27;
		NimStringDesc* LOC32;
		NimStringDesc* LOC33;
		NimStringDesc* LOC34;
		LOC26 = 0;
		LOC27 = 0;
		LOC27 = result;
		if (!(LOC27)) goto LA28;
		LOC27 = !((col == columns));
		LA28: ;
		LOC26 = LOC27;
		if (!(LOC26)) goto LA29;
		LOC26 = (((NI) 0) < columns);
		LA29: ;
		if (!LOC26) goto LA30;
		LOC32 = 0;
		LOC33 = 0;
		LOC33 = nimIntToStr(columns);
		LOC34 = 0;
		LOC34 = nimIntToStr(col);
		LOC32 = rawNewString(LOC33->Sup.len + LOC34->Sup.len + 37);
appendString(LOC32, LOC33);
appendString(LOC32, ((NimStringDesc*) &TMP390));
appendString(LOC32, LOC34);
appendString(LOC32, ((NimStringDesc*) &TMP391));
		error_257049((&(*my)), (NI)(oldpos + ((NI) 1)), LOC32);
	}
	LA30: ;
	(*my).currrow += ((NI) 1);
	return result;
}

N_NIMCALL(NI, processedrows_257214)(Csvparser257007* my) {
	NI result;
{	result = 0;
	result = (*my).currrow;
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}
NIM_EXTERNC N_NOINLINE(void, stdlib_parsecsvInit)(void) {
}

NIM_EXTERNC N_NOINLINE(void, stdlib_parsecsvDatInit)(void) {
static TNimNode* TMP382[7];
static TNimNode TMP135[9];
NTI257007.size = sizeof(Csvparser257007);
NTI257007.kind = 17;
NTI257007.base = (&NTI255024);
TMP382[0] = &TMP135[1];
TMP135[1].kind = 1;
TMP135[1].offset = offsetof(Csvparser257007, row);
TMP135[1].typ = (&NTI120008);
TMP135[1].name = "row";
TMP382[1] = &TMP135[2];
TMP135[2].kind = 1;
TMP135[2].offset = offsetof(Csvparser257007, filename);
TMP135[2].typ = (&NTI149);
TMP135[2].name = "filename";
TMP382[2] = &TMP135[3];
TMP135[3].kind = 1;
TMP135[3].offset = offsetof(Csvparser257007, sep);
TMP135[3].typ = (&NTI147);
TMP135[3].name = "sep";
TMP382[3] = &TMP135[4];
TMP135[4].kind = 1;
TMP135[4].offset = offsetof(Csvparser257007, quote);
TMP135[4].typ = (&NTI147);
TMP135[4].name = "quote";
TMP382[4] = &TMP135[5];
TMP135[5].kind = 1;
TMP135[5].offset = offsetof(Csvparser257007, esc);
TMP135[5].typ = (&NTI147);
TMP135[5].name = "esc";
TMP382[5] = &TMP135[6];
TMP135[6].kind = 1;
TMP135[6].offset = offsetof(Csvparser257007, skipwhite);
TMP135[6].typ = (&NTI138);
TMP135[6].name = "skipWhite";
TMP382[6] = &TMP135[7];
TMP135[7].kind = 1;
TMP135[7].offset = offsetof(Csvparser257007, currrow);
TMP135[7].typ = (&NTI108);
TMP135[7].name = "currRow";
TMP135[0].len = 7; TMP135[0].kind = 2; TMP135[0].sons = &TMP382[0];
NTI257007.node = &TMP135[0];
NTI257009.size = sizeof(Csverror257009);
NTI257009.kind = 17;
NTI257009.base = (&NTI3431);
TMP135[8].len = 0; TMP135[8].kind = 2;
NTI257009.node = &TMP135[8];
NTI257032.size = sizeof(Csverror257009*);
NTI257032.kind = 22;
NTI257032.base = (&NTI257009);
NTI257032.marker = TMP384;
}

