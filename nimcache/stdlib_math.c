/* Generated by Nim Compiler v0.11.3 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -Os  -I/data4/NimCompiler/Nim/lib -o nimcache/stdlib_math.o nimcache/stdlib_math.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <math.h>
typedef struct Runningstat144047 Runningstat144047;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  Runningstat144047  {
NI n;
NF sum;
NF min;
NF max;
NF mean;
NF oldm;
NF olds;
NF news;
};
typedef N_NIMCALL_PTR(void, TY3289) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3294) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3289 marker;
TY3294 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
N_NIMCALL(NF, variance_144096)(Runningstat144047* s);
TNimType NTI144047; /* RunningStat */
extern TNimType NTI108; /* int */
extern TNimType NTI128; /* float */

N_NIMCALL(void, push_144064)(Runningstat144047* s, NF x) {
	(*s).n += ((NI) 1);
	{
		if (!((*s).n == ((NI) 1))) goto LA3;
		(*s).min = x;
		(*s).max = x;
		(*s).oldm = x;
		(*s).mean = x;
		(*s).olds = 0.0;
	}
	goto LA1;
	LA3: ;
	{
		{
			if (!(x < (*s).min)) goto LA8;
			(*s).min = x;
		}
		LA8: ;
		{
			if (!((*s).max < x)) goto LA12;
			(*s).max = x;
		}
		LA12: ;
		(*s).mean = ((NF)((*s).oldm) + (NF)(((NF)(((NF)(x) - (NF)((*s).oldm))) / (NF)(((double) ((*s).n))))));
		(*s).news = ((NF)((*s).olds) + (NF)(((NF)(((NF)(x) - (NF)((*s).oldm))) * (NF)(((NF)(x) - (NF)((*s).mean))))));
		(*s).oldm = (*s).mean;
		(*s).olds = (*s).news;
	}
	LA1: ;
	(*s).sum = ((NF)((*s).sum) + (NF)(x));
}

N_NIMCALL(NF, variance_144096)(Runningstat144047* s) {
	NF result;
	result = 0;
	{
		if (!(((NI) 1) < (*s).n)) goto LA3;
		result = ((NF)((*s).news) / (NF)(((double) ((NI)((*s).n - ((NI) 1))))));
	}
	LA3: ;
	return result;
}

N_NIMCALL(NF, standarddeviation_144106)(Runningstat144047* s) {
	NF result;
	NF LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = variance_144096(s);
	result = sqrt(LOC1);
	return result;
}

N_NIMCALL(NU8, classify_142426)(NF x) {
	NU8 result;
{	result = 0;
	{
		if (!(x == 0.0)) goto LA3;
		{
			if (!(((NF)(1.0000000000000000e+00) / (NF)(x)) == INF)) goto LA7;
			result = ((NU8) 2);
			goto BeforeRet;
		}
		goto LA5;
		LA7: ;
		{
			result = ((NU8) 3);
			goto BeforeRet;
		}
		LA5: ;
	}
	LA3: ;
	{
		if (!(((NF)(x) * (NF)(5.0000000000000000e-01)) == x)) goto LA12;
		{
			if (!(0.0 < x)) goto LA16;
			result = ((NU8) 5);
			goto BeforeRet;
		}
		goto LA14;
		LA16: ;
		{
			result = ((NU8) 6);
			goto BeforeRet;
		}
		LA14: ;
	}
	LA12: ;
	{
		if (!!((x == x))) goto LA21;
		result = ((NU8) 4);
		goto BeforeRet;
	}
	LA21: ;
	result = ((NU8) 0);
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

N_NIMCALL(NF, sum_319273)(NF* x, NI xLen0) {
	NF result;
	result = 0;
	{
		NF i_319315;
		NI i_319319;
		i_319315 = 0;
		i_319319 = ((NI) 0);
		{
			while (1) {
				if (!(i_319319 < xLen0)) goto LA3;
				i_319315 = x[i_319319];
				result = ((NF)(result) + (NF)(i_319315));
				i_319319 += ((NI) 1);
			} LA3: ;
		}
	}
	return result;
}

N_NIMCALL(NI, nextpoweroftwo_142531)(NI x) {
	NI result;
	result = 0;
	result = (NI)(x - ((NI) 1));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 32))));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 16))));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 8))));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 4))));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 2))));
	result = (NI)(result | (NI)((NU64)(result) >> (NU64)(((NI) 1))));
	result += ((NI) ((NI)(((NI) 1) + ((NI) ((x <= ((NI) 0)))))));
	return result;
}
NIM_EXTERNC N_NOINLINE(void, stdlib_mathInit)(void) {
}

NIM_EXTERNC N_NOINLINE(void, stdlib_mathDatInit)(void) {
static TNimNode* TMP240[8];
static TNimNode TMP25[9];
NTI144047.size = sizeof(Runningstat144047);
NTI144047.kind = 18;
NTI144047.base = 0;
NTI144047.flags = 3;
TMP240[0] = &TMP25[1];
TMP25[1].kind = 1;
TMP25[1].offset = offsetof(Runningstat144047, n);
TMP25[1].typ = (&NTI108);
TMP25[1].name = "n";
TMP240[1] = &TMP25[2];
TMP25[2].kind = 1;
TMP25[2].offset = offsetof(Runningstat144047, sum);
TMP25[2].typ = (&NTI128);
TMP25[2].name = "sum";
TMP240[2] = &TMP25[3];
TMP25[3].kind = 1;
TMP25[3].offset = offsetof(Runningstat144047, min);
TMP25[3].typ = (&NTI128);
TMP25[3].name = "min";
TMP240[3] = &TMP25[4];
TMP25[4].kind = 1;
TMP25[4].offset = offsetof(Runningstat144047, max);
TMP25[4].typ = (&NTI128);
TMP25[4].name = "max";
TMP240[4] = &TMP25[5];
TMP25[5].kind = 1;
TMP25[5].offset = offsetof(Runningstat144047, mean);
TMP25[5].typ = (&NTI128);
TMP25[5].name = "mean";
TMP240[5] = &TMP25[6];
TMP25[6].kind = 1;
TMP25[6].offset = offsetof(Runningstat144047, oldm);
TMP25[6].typ = (&NTI128);
TMP25[6].name = "oldM";
TMP240[6] = &TMP25[7];
TMP25[7].kind = 1;
TMP25[7].offset = offsetof(Runningstat144047, olds);
TMP25[7].typ = (&NTI128);
TMP25[7].name = "oldS";
TMP240[7] = &TMP25[8];
TMP25[8].kind = 1;
TMP25[8].offset = offsetof(Runningstat144047, news);
TMP25[8].typ = (&NTI128);
TMP25[8].name = "newS";
TMP25[0].len = 8; TMP25[0].kind = 2; TMP25[0].sons = &TMP240[0];
NTI144047.node = &TMP25[0];
}

